1. Backend â€“ Endpoints

POST /identity
Cria uma nova identidade:

{
  "identityId": "abc123...",
  "commitment": "hash..."
}


POST /attributes
Recebe:

{
  "identityId": "abc123...",
  "birthdate": "1999-11-11",
  "country": "PT"
}


Atualiza essa identity em memÃ³ria (nÃ£o cria nova) e devolve:

{
  "identityId": "abc123...",
  "commitment": "hash_atualizado...",
  "attributesRoot": "hash_dos_atributos..."
}


POST /proof
Recebe algo tipo:

{
  "identityId": "abc123...",
  "templateId": "age_over_18_and_resident_pt"
}


E devolve o bundle:

{
  "identityId": "abc123...",
  "proof": {
    "identityId": "abc123...",
    "templateId": "age_over_18_and_resident_pt",
    "proofHash": "hash_da_prova...",
    "issuedAt": "timestamp..."
  }
}


POST /proof/verify
Recebe:

{
  "identityId": "abc123...",
  "proof": {
    "identityId": "abc123...",
    "templateId": "age_over_18_and_resident_pt",
    "proofHash": "hash_da_prova...",
    "issuedAt": "timestamp..."
  }
}


O backend recalcula internamente e responde:

{ "valid": true }


ou

{ "valid": false }

ðŸ”¹ 2. Agent UI

Cria identity

Guarda atributos (DOB + paÃ­s)

Gera proof

Exporta Identity JSON + Proof JSON prontos para o Verifier

ðŸ”¹ 3. Verifier UI

Aceita os dois JSONs

Faz POST /proof/verify

Mostra o { "valid": true/false }

ðŸ”¹ 4. O que esse valid: true quer dizer, na prÃ¡tica

A prova foi mesmo gerada por nÃ³s para aquela identityId.

O proofHash nÃ£o foi inventado Ã  mÃ£o.

O par identity + proof Ã© coerente.

Se alguÃ©m alterar um byte na proof â†’ passa a valid: false.

Isto Ã© camada 1: integridade criptogrÃ¡fica do par identityâ€“proof.